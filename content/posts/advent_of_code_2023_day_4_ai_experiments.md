---
title: "AI-dvent of Code 2023: Day 4"
date: 2023-12-05
tags: ["functional","kotlin","advent-of-code","generative-ai"]
featured_image: "/images/advent_of_code_2023_day_4_ai_experiments_title.png"
---

After the glimmer of hope on [day 3]({{< ref "advent_of_code_2023_day_3_ai_experiments.md" >}}) I was quite optimistic
for the [day 4 puzzle](https://adventofcode.com/2023/day/4). I kept going with the `phind-codellama` model.
I continued with keeping the model on a fairly tight leash and just being very specific as to what I wanted it to do.

# What's the puzzle?

So, for the first part, we had to parse a text file and then match up numbers and winning numbers.

Fairly early on, I asked the model to come up for a test case for my parsing code, and this is what it came up with:

```
@Test
fun testParseCards() {
    val input = listOf(
        "Card 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53",
        "Card 2: 13 32 20 16 61 | 61 30 68 82 17 32 24 19")
    val expected = listOf(
        Pair(setOf(41, 48, 83, 86, 17), setOf(83, 86, 6, 31, 17, 9, 48, 53)),
        Pair(setOf(13, 32, 20, 16, 61), setOf(61, 30, 68, 82, 17, 32, 24, 19))
    )
    assertEquals(expected, parseCards(input))
}
```

Which is fairly impressive. Though I still have been creating the function first and asking the
model for a test straight after. Really I should be creating the test first, but I'm still finding my feet. Any
excuse really ;-)

For part 1, I got a bit enthused about playing with Kotlin, so I didn't end up consulting the model, for the rest of
the solution:

```kotlin
fun parseNumbers(input: String) =
    input.split(" ")
        .filter { !it.equals("") }
        .map { it.toInt() }.toSet()

fun parseCards(input: List<String>) =
    input.map { line ->
        val (_, winning, mine) = line.split(Regex("[:|]"))
        Pair(parseNumbers(winning), parseNumbers(mine))
    }

fun calculateWinners(input: List<Pair<Set<Int>, Set<Int>>>) =
    input.map { (winning, mine) -> 
        winning.intersect(mine).size 
    }
```

I am really beginning to enjoy the cleanness of using kotlin functionally. The destructuring is what I'm used to from
Scala and Haskell, and for AoC I find the conciseness that just functions allow really useful.

# Code Analysis

For part 2, gave the model some homework. I told it what I had done and asked it to generate some code based on it:

```
>>> """
... based on the following code, I would like to have a function 
... that processes the list of strings in reverse and creates a 
... stack where the number of cumulative wins are placed:
... 
... [see code above]
... """
```Kotlin
fun calculateCumulativeWins(input: List<String>): Stack<Int> {
    val cards = parseCards(input)
    val winners = calculateWinners(cards).reversed() 
    
    val cumulativeWins = winners.scan(0, Int::plus) 
    return Stack<Int>().apply { addAll(cumulativeWins) }
}

In this example, I've added an extension function `scan` to 
calculate the cumulative sum. It takes the list of winners 
and applies the `plus` operation in sequence, accumulating
the results. The result is then converted into a `Stack<Int>` 
for easy access.
```

Now, that didn't work - for a pretty obvious reason, but let's see whether the model can figure it out:

```
>>> """
... The code produces the following error, is there an import missing?
...
... Unresolved reference: Stack
... """
Yes, you need to import the `Stack` class from the `java.util` package 
at the beginning of your file:

```Kotlin
import java.util.Stack
```

Less impressive was that my initial idea of creating a stack and working out the solution by going through the list
backwards didn't get anywhere, but that was my dead end.

Eventually, I just ended up with a solution based on some bits generated by the AI:

```
>>> then it should process the winners list by iterating 
... over the winners array and adding e to each of the mutable 
... list from the index and for n elements
To modify the `calculateCumulativeWins` function as you described, 
you can use the following code:

```Kotlin
fun calculateCumulativeWins(input: List<String>): MutableList<Int> {
    val cards = parseCards(input)
    val winners = calculateWinners(cards).reversed() 
    
    val cumulativeWins = MutableList(winners.size) { 0 } 
    
    for (index in winners.indices) {
        val e = winners[index]
        for (n in index until winners.size) {
            cumulativeWins[n] += e 
        }
    }
    
    return cumulativeWins 
}
```

This wasn't a million miles away from the solution I used:


- https://github.com/beny23/advent-of-code/blob/main/2023/kotlin-ai/day4/src/main/kotlin/Part1.kt
- https://github.com/beny23/advent-of-code/blob/main/2023/kotlin-ai/day4/src/main/kotlin/Part2.kt

# Conclusion

The conclusions for day 4 were pretty much the same as [day 3]({{< ref "advent_of_code_2023_day_3_ai_experiments.md" >}})
and I am still pretty sure that I'm faster googling than having a conversation with the LLM. But I also haven't 
seen it completely fail yet.

See you on Day 5 when there is a choice between brute force and a bit of thinking.